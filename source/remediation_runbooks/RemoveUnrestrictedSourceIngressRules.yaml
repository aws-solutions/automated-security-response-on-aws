# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0
description: |
  ### Document Name - AWSConfigRemediation-RemoveUnrestrictedSourceIngressRules (Customized)

  ## What does this document do?
  This runbook replaces all ingress rules from the security group you specify that allow traffic from all source addresses using the [RevokeSecurityGroupIngress](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RevokeSecurityGroupIngress.html) API.

  ## Input Parameters
  * SecurityGroupId: (Required) The ID of the security group that you want to remove ingress rules that allow traffic from all source addresses from.
  * IPRanges: (Required) List of the CIDR which replaces the source Ingress Rule
  * Ports: (Required) List of valid ports to remediate
  * AutomationAssumeRole: (Required) The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that allows Systems Manager Automation to perform the actions on your behalf.

  ## Output Parameters
  * RemoveUnrestrictedIngressRulesAndVerify.Response - The standard HTTP response from the RevokeSecurityGroupIngress API.

schemaVersion: '0.3'
assumeRole: '{{ AutomationAssumeRole }}'
parameters:
  AutomationAssumeRole:
    type: String
    description: (Required) The ARN of the role that allows Automation to perform the actions on your behalf.
    allowedPattern: '^arn:(?:aws|aws-us-gov|aws-cn):iam::\d{12}:role/[\w+=,.@-]+$'
  SecurityGroupId:
    type: String
    description: (Required) The ID of the security group that you want to remove ingress rules that allow traffic from all source addresses from.
    allowedPattern: ^sg-[a-z0-9]+$
  IpRanges:
    type: StringList
    description: (Required) List of the CIDR which replaces the source Ingress Rule
  AllowedPort:
    type: StringList
    description: (Required) List of valid ports to remediate

outputs:
- RemoveUnrestrictedIngressRulesAndVerify.Response
mainSteps:
- name: RemoveUnrestrictedIngressRulesAndVerify
  action: aws:executeScript
  timeoutSeconds: 600
  isEnd: true
  description: |
    ## RemoveUnrestrictedIngressRulesAndVerify
    Removes all ingress rules that allow traffic from all source addresses from the security group you specified in the SecurityGroupId parameter and verifies successful rules removal.
    ## Outputs
    * Response: The standard HTTP response from the RevokeSecurityGroupIngress API.
  inputs:
    Runtime: python3.7
    Handler: remove_sg_unrestricted_ingress_rules
    InputPayload:
      SecurityGroupId: "{{ SecurityGroupId }}"
      IpRanges: "{{ IpRanges }}"
      AllowedPort: "{{ IpRanges }}"
    Script: |-
      import json
      import boto3

      def remove_unrestricted_ingress_rules_ipv4(ec2, security_group_id, ip_ranges, ports):
          paginator = ec2.get_paginator('describe_security_groups')
          response_iterator = paginator.paginate(
              Filters=[ {'Name': 'ip-permission.cidr', 'Values': [ '0.0.0.0/0' ] },],
              GroupIds=[security_group_id]
          )

          ip_permissions = []
          new_permissions = []
          for sgs in response_iterator:
            for sg in sgs.get('SecurityGroups'):
              for ip in sg.get('IpPermissions'):
                for rule in ip.get('IpRanges'):
                  if(rule['CidrIp'] == '0.0.0.0/0' and str(ip["FromPort"]) in ports):
                    permissions_dict = {'IpProtocol': ip['IpProtocol'], 'IpRanges': [{'CidrIp': '0.0.0.0/0'}]}
                    if not ip.get("FromPort") is None:
                      permissions_dict["FromPort"] = ip["FromPort"]
                    if not ip.get("ToPort") is None:
                      permissions_dict["ToPort"] = ip["ToPort"]
                    ip_permissions.append(permissions_dict)

                    for allow_ip_range in ip_ranges:
                      permissions_new = permissions_dict.copy()
                      permissions_new["IpRanges"] = [{'CidrIp': allow_ip_range}]
                      if verify_sg_rule_already_exist(ec2, permissions_new, security_group_id, allow_ip_range) == False:
                        new_permissions.append(permissions_new)

          if ip_permissions:
            result = ec2.revoke_security_group_ingress(GroupId=security_group_id, IpPermissions=ip_permissions)
            if new_permissions:
              ec2.authorize_security_group_ingress(GroupId=security_group_id, IpPermissions=new_permissions)
            return result

      def verify_sg_rule_already_exist(ec2, rule, security_group_id, allow_ip_range):
          """
          Check if the sg rule already exist into a security group

          :param rule:
              - 'IpProtocol' (str): protocol (e.g, 'tcp').
              - 'FromPort' (int): Port begins of the rule.
              - 'ToPort' (int): Port ends of the rule.
              - 'CidrIp' (str): IP Address allow it by the rule with CIDR format (e.g, '0.0.0.0/0' )
          :param security_group_id: Security group ID
          :return: True if the rule is already exist, False in otherwise.
          """
          response = ec2.describe_security_groups(GroupIds=[security_group_id])

          for group in response['SecurityGroups']:
            for existing_rule in group['IpPermissions']:
              if (
                  existing_rule['IpProtocol'] == rule['IpProtocol']
                  and existing_rule['FromPort'] == rule['FromPort']
                  and existing_rule['ToPort'] == rule['ToPort']
              ):
                for ip_range in existing_rule['IpRanges']:
                  if ip_range['CidrIp'] == allow_ip_range:
                      return True
          return False

      def verify_sg_unrestricted_rules_removed(ec2, security_group_id, ports):
        error_message = f"Verification Failed. Security Group {security_group_id} unrestricted ingress rules not removed "
        unrestricted_ingress_rules_ipv4 = ec2.describe_security_groups(GroupIds=[ security_group_id ], Filters=[{'Name': 'ip-permission.cidr','Values': ['0.0.0.0/0' ]}])

        filtered_groups = []
        for group in unrestricted_ingress_rules_ipv4['SecurityGroups']:
          portRules = [str(rule['FromPort']) for rule in group['IpPermissions']]
          if not any(port in portRules for port in ports):
              filtered_groups.append(group)

        if filtered_groups:
          raise Exception(error_message)

      def remove_sg_unrestricted_ingress_rules(event, context):
        ec2 = boto3.client('ec2')
        security_group_id = event['SecurityGroupId']
        ip_ranges = event['IpRanges']
        ports = event['AllowedPort']
        ipv4_response = remove_unrestricted_ingress_rules_ipv4(ec2, security_group_id, ip_ranges, ports)
        verify_sg_unrestricted_rules_removed(ec2, security_group_id, ports)

        response = []
        if ipv4_response:
          response.append(ipv4_response)
        return response
  outputs:
  - Name: Response
    Selector: $.Payload
    Type: MapList

- name: UpdateFinding
  action: 'aws:executeAwsApi'
  inputs:
    Service: securityhub
    Api: BatchUpdateFindings
    FindingIdentifiers:
    - Id: '{{ParseInput.FindingId}}'
      ProductArn: '{{ParseInput.ProductArn}}'
    Note:
      Text: 'Disabled public access to the security group {{ ParseInput.GroupId }}.'
      UpdatedBy: 'ASR-CIS_1.2.0_4.1'
    Workflow:
      Status: RESOLVED
  description: Update finding
  isEnd: true
